-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/githubuser/blackjack#readme</a>
@package blackjack
@version 0.1.0.0


-- | This module defines a class of non-deterministic dynamic programming
--   problems and the means to solve/optimize them. The framework targets a
--   slightly different set of problems, but some parts take after:
--   <a>https://hackage.haskell.org/package/HyloDP-1.0.0/docs/HyloDP-Base.html</a>,
--   but targets
--   
--   This module does: - provide modeling for non-deterministic dynamic
--   programming - this allows the "reward" of an action to depend on
--   multiple successor states - abstract over the search procedure used to
--   determine the optimal action, allowing for: - exhaustive searches over
--   finite domains - a golden section search for unimodal objectives over
--   "infinite" domains - something smarter if you want? - solve the
--   problem while returning the entire table of subsolutions - (the solver
--   needs the entire table anyway).
--   
--   It does not: - use algebraic infrastructure to explain dynamic
--   programming is actually described by a hylomorphism (not sure if this
--   one actually still is) - use MemoTrie (it explodes for some reason,
--   but generally speaking the hashmap isn't the bottleneck anyway) - use
--   Semirings to describe formulate optimality and the reported statistics
--   at the type level
module DP

-- | The type of dynamic programming problems valued in <tt>v</tt>, with
--   states <tt>s</tt> and actions <tt>a</tt>.
--   
--   The (usually) Monad <tt>m</tt> can be used to compute something if you
--   need, usually it's one of: - Identity - IO/ST - a transformer stack
--   including memoization
--   
--   (The decomposition into subproblems is encoded in <a>actValue</a>).
data DPProblem s v a m
DPProblem :: Search s v a m -> (s -> (s -> m v) -> a -> m v) -> DPProblem s v a m

-- | The search procedure over <tt>a</tt>.
[search] :: DPProblem s v a m -> Search s v a m

-- | Returns the objective value of performing an action <tt>a</tt> in a
--   state <tt>s</tt>.
[actValue] :: DPProblem s v a m -> s -> (s -> m v) -> a -> m v

-- | Given a function `s -&gt; Either v [a]` indicating whether a state is
--   either: - terminal with value <tt>v</tt> - allows for actions `[a]` to
--   be taken this procedure exhaustively searches the list for the action
--   with the optimal objective.
enumSearch :: (Ord v, Monad m) => (s -> Either v [a]) -> Search s v a m

-- | Given an injection <tt>mk</tt> of values <tt>x</tt> into actions
--   <tt>a</tt>, this procedure performs a golden section search over
--   <tt>x</tt> for the objective of `mk x`.
uniSearch :: (Ord v, Monad m, Floating x) => Int -> (x -> a) -> x -> x -> Search s v a m

-- | <a>execDP</a> solves a <a>DPProblem</a> in <a>IO</a> from a given
--   initial state, returning the entire table mapping states to their
--   optimal actions and objective values. Uses an <a>IORef</a> to a
--   <tt>HashMap</tt> for memoization.
execDP :: Hashable s => DPProblem s v a IO -> s -> IO (HashMap s (v, Maybe a))

-- | A "trick" to reduce the output of <a>execDP</a> to only the relevant
--   parts. Instantiate this with the output of an <a>execDP</a> call and
--   rerun <a>execDP</a> with this problem instead.
reducedP :: (Monad m, Ord v, Hashable s) => HashMap s (v, Maybe a) -> DPProblem s v a m -> DPProblem s v a m

-- | <a>reducedDP</a> solves a <a>DPProblem</a> in <a>IO</a> from a given
--   initial state, returning the table mapping reachable states to their
--   optimal actions and objective values.
--   
--   A state <tt>s</tt> is reachable if it's either initial, or the
--   objective value of a reachable state <tt>s'</tt> after taking the
--   optimal action refers to <tt>s</tt>.
reducedDP :: (Hashable s, Ord v) => DPProblem s v a IO -> s -> IO (HashMap s (v, Maybe a))


-- | This module provides some wrappers for computing some statistics for
--   your <tt>DPProblem</tt>.
--   
--   Make sure your inputs are independent if you like having correct
--   outputs.
module Probability

-- | Compute the value of the statistic for a uniform mixture of
--   distributions.
avg :: Mixture a => [a] -> a

-- | The class of statistics containing enough informations to calculate an
--   expected value.
--   
--   Remark, if `HasMean a r`, `Mixture a`, and `Mixture r`, it does not
--   necessarily hold that `mean . weightedAvg == weightedAvg . fmap
--   (second mean)`. For example, see <a>Log1P</a>.
class HasMean a r | a -> r

-- | Extract the expected value. Generally this should satisfy `mean .
--   fromRational = id`.
mean :: HasMean a r => a -> r
class HasVariance a r | a -> r
variance :: HasVariance a r => a -> r

-- | A statistic `V :: X -&gt; v` supports mixtures if: - there is a
--   function $m$ - $f_X(x) = pf_Y(x) + (1-p)f_Z(x)$ implies $V[X] = m(p,
--   V[Y], V[Z])
--   
--   The method <a>weightedAvg</a> generalizes this to the $n$-ary case.
class Mixture a

-- | Compute the value of the statistic for a mixture of distributions.
weightedAvg :: Mixture a => [(Double, a)] -> a

-- | A wrapper to compute the expected value of the logarithm of X plus
--   one, E[log(1 + X)]. This is equivalent to the logarithm of the
--   expected geometric growth rate.
--   
--   Note that all this does is map an incoming value <tt>x</tt> to `log (1
--   + x)` and outgoing values <tt>x</tt> to `exp(x) - 1`.
newtype Log1P a
Log1P :: a -> Log1P a
[getLog1P] :: Log1P a -> a

-- | A wrapper to compute the expected value E[X], also known as the
--   <tt>Identity</tt>.
newtype Mean a
Mean :: a -> Mean a
[getMean] :: Mean a -> a

-- | A wrapper to search for the objective value with the maximal expected
--   value.
--   
--   This ensures that if `mean x &lt; mean y` then `MaxMean x &lt; MaxMean
--   y`.
newtype MaxMean a
MaxMean :: a -> MaxMean a
[getMaxMean] :: MaxMean a -> a

-- | A wrapper to search for the objective value with the minimal expected
--   value.
--   
--   This ensures that if `mean x &gt;= mean y` then `MinMean x &lt;
--   MinMean y`.
newtype MinMean a
MinMean :: a -> MinMean a
[getMinMean] :: MinMean a -> a

-- | A wrapper to compute the variance and expected value of X. Requires
--   its first argument to have expected values to work.
data Variance a b
Variance :: !a -> !b -> Variance a b
[unVariance] :: Variance a b -> !a
[getVariance] :: Variance a b -> !b
instance GHC.Classes.Ord a => GHC.Classes.Ord (Probability.Mean a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Probability.Mean a)
instance GHC.Float.Floating a => GHC.Float.Floating (Probability.Mean a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Probability.Mean a)
instance GHC.Num.Num a => GHC.Num.Num (Probability.Mean a)
instance GHC.Show.Show a => GHC.Show.Show (Probability.Mean a)
instance GHC.Enum.Bounded a => GHC.Enum.Bounded (Probability.Log1P a)
instance GHC.Base.Functor Probability.Log1P
instance GHC.Show.Show a => GHC.Show.Show (Probability.Log1P a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Probability.MaxMean a)
instance GHC.Num.Num a => GHC.Num.Num (Probability.MaxMean a)
instance GHC.Show.Show a => GHC.Show.Show (Probability.MaxMean a)
instance GHC.Real.Fractional a => GHC.Real.Fractional (Probability.MinMean a)
instance GHC.Num.Num a => GHC.Num.Num (Probability.MinMean a)
instance GHC.Show.Show a => GHC.Show.Show (Probability.MinMean a)
instance (GHC.Show.Show a, GHC.Show.Show b) => GHC.Show.Show (Probability.Variance a b)
instance Probability.HasVariance (Probability.Variance a b) b
instance (GHC.Real.Fractional b, Probability.HasMean a b, Probability.Mixture a) => Probability.Mixture (Probability.Variance a b)
instance Probability.HasMean a r => Probability.HasMean (Probability.Variance a b) r
instance (Probability.HasMean a b, GHC.Num.Num a, GHC.Num.Num b) => GHC.Num.Num (Probability.Variance a b)
instance (Probability.HasMean a b, GHC.Real.Fractional a, GHC.Real.Fractional b) => GHC.Real.Fractional (Probability.Variance a b)
instance (Probability.HasMean a r, GHC.Classes.Eq r) => GHC.Classes.Eq (Probability.MinMean a)
instance (Probability.HasMean a r, GHC.Classes.Ord r) => GHC.Classes.Ord (Probability.MinMean a)
instance Probability.HasMean a r => Probability.HasMean (Probability.MinMean a) r
instance Probability.Mixture a => Probability.Mixture (Probability.MinMean a)
instance (Probability.HasMean a r, GHC.Classes.Eq r) => GHC.Classes.Eq (Probability.MaxMean a)
instance (Probability.HasMean a r, GHC.Classes.Ord r) => GHC.Classes.Ord (Probability.MaxMean a)
instance Probability.HasMean a r => Probability.HasMean (Probability.MaxMean a) r
instance Probability.Mixture a => Probability.Mixture (Probability.MaxMean a)
instance GHC.Base.Applicative Probability.Log1P
instance GHC.Float.Floating a => GHC.Num.Num (Probability.Log1P a)
instance GHC.Float.Floating a => GHC.Real.Fractional (Probability.Log1P a)
instance (Probability.HasMean a r, GHC.Float.Floating r) => Probability.HasMean (Probability.Log1P a) r
instance GHC.Real.Fractional a => Probability.Mixture (Probability.Log1P a)
instance Probability.HasMean (Probability.Mean a) a
instance GHC.Real.Fractional a => Probability.Mixture (Probability.Mean a)


-- | This module defines a variant of Blackjack and formulates the optimal
--   strategy as a <a>DPProblem</a>.
module Blackjack
computeAndStore :: IO ()
dumpCSV' :: IO ()
instance GHC.Generics.Generic Blackjack.Hand
instance GHC.Show.Show Blackjack.Hand
instance GHC.Classes.Ord Blackjack.Hand
instance GHC.Classes.Eq Blackjack.Hand
instance GHC.Generics.Generic Blackjack.Blackjack
instance GHC.Show.Show Blackjack.Blackjack
instance GHC.Classes.Ord Blackjack.Blackjack
instance GHC.Classes.Eq Blackjack.Blackjack
instance GHC.Generics.Generic Blackjack.Action
instance GHC.Show.Show Blackjack.Action
instance GHC.Classes.Ord Blackjack.Action
instance GHC.Classes.Eq Blackjack.Action
instance Data.Serialize.Serialize Blackjack.Blackjack
instance Data.Serialize.Serialize Blackjack.Hand
instance Data.Serialize.Serialize Blackjack.Action
instance Data.Hashable.Class.Hashable Blackjack.Blackjack
instance Data.Hashable.Class.Hashable Blackjack.Hand
instance GHC.Base.Semigroup Blackjack.Hand
instance GHC.Base.Monoid Blackjack.Hand
