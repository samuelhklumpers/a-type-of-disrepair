<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>DP</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">blackjack-0.1.0.0</span><ul class="links" id="page-menu"><li><a href="src/DP.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">DP</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module defines a class of non-deterministic dynamic programming problems and the means to solve/optimize them.
The framework targets a slightly different set of problems, but some parts take after: <a href="https://hackage.haskell.org/package/HyloDP-1.0.0/docs/HyloDP-Base.html">https://hackage.haskell.org/package/HyloDP-1.0.0/docs/HyloDP-Base.html</a>, but targets</p><p>This module does:
- provide modeling for non-deterministic dynamic programming
    - this allows the &quot;reward&quot; of an action to depend on multiple successor states
- abstract over the search procedure used to determine the optimal action, allowing for:
    - exhaustive searches over finite domains
    - a golden section search for unimodal objectives over &quot;infinite&quot; domains
    - something smarter if you want?
- solve the problem while returning the entire table of subsolutions
    - (the solver needs the entire table anyway).</p><p>It does not:
- use algebraic infrastructure to explain dynamic programming is actually described by a hylomorphism (not sure if this one actually still is)
- use MemoTrie (it explodes for some reason, but generally speaking the hashmap isn't the bottleneck anyway)
- use Semirings to describe formulate optimality and the reported statistics at the type level</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:DPProblem">DPProblem</a> s v a m = <a href="#v:DPProblem">DPProblem</a> {<ul class="subs"><li><a href="#v:search">search</a> :: Search s v a m</li><li><a href="#v:actValue">actValue</a> :: s -&gt; (s -&gt; m v) -&gt; a -&gt; m v</li></ul>}</li><li class="src short"><a href="#v:enumSearch">enumSearch</a> :: (<a href="../base-4.18.2.1/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> v, <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (s -&gt; <a href="../base-4.18.2.1/Data-Either.html#t:Either" title="Data.Either">Either</a> v [a]) -&gt; Search s v a m</li><li class="src short"><a href="#v:uniSearch">uniSearch</a> :: (<a href="../base-4.18.2.1/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> v, <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="../base-4.18.2.1/Numeric.html#t:Floating" title="Numeric">Floating</a> x) =&gt; <a href="../base-4.18.2.1/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; (x -&gt; a) -&gt; x -&gt; x -&gt; Search s v a m</li><li class="src short"><a href="#v:execDP">execDP</a> :: Hashable s =&gt; <a href="DP.html#t:DPProblem" title="DP">DPProblem</a> s v a <a href="../base-4.18.2.1/System-IO.html#t:IO" title="System.IO">IO</a> -&gt; s -&gt; <a href="../base-4.18.2.1/System-IO.html#t:IO" title="System.IO">IO</a> (HashMap s (v, <a href="../base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a))</li><li class="src short"><a href="#v:reducedP">reducedP</a> :: (<a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="../base-4.18.2.1/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> v, Hashable s) =&gt; HashMap s (v, <a href="../base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) -&gt; <a href="DP.html#t:DPProblem" title="DP">DPProblem</a> s v a m -&gt; <a href="DP.html#t:DPProblem" title="DP">DPProblem</a> s v a m</li><li class="src short"><a href="#v:reducedDP">reducedDP</a> :: (Hashable s, <a href="../base-4.18.2.1/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> v) =&gt; <a href="DP.html#t:DPProblem" title="DP">DPProblem</a> s v a <a href="../base-4.18.2.1/System-IO.html#t:IO" title="System.IO">IO</a> -&gt; s -&gt; <a href="../base-4.18.2.1/System-IO.html#t:IO" title="System.IO">IO</a> (HashMap s (v, <a href="../base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a))</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:DPProblem" class="def">DPProblem</a> s v a m <a href="src/DP.html#DPProblem" class="link">Source</a> <a href="#t:DPProblem" class="selflink">#</a></p><div class="doc"><p>The type of dynamic programming problems valued in <code>v</code>, with states <code>s</code> and actions <code>a</code>.</p><p>The (usually) Monad <code>m</code> can be used to compute something if you need, usually it's one of:
- Identity
- IO/ST
- a transformer stack including memoization</p><p>(The decomposition into subproblems is encoded in <code><a href="DP.html#v:actValue" title="DP">actValue</a></code>).</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:DPProblem" class="def">DPProblem</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:search" class="def">search</a> :: Search s v a m</dfn><div class="doc"><p>The search procedure over <code>a</code>.</p></div></li><li><dfn class="src"><a id="v:actValue" class="def">actValue</a> :: s -&gt; (s -&gt; m v) -&gt; a -&gt; m v</dfn><div class="doc"><p>Returns the objective value of performing an action <code>a</code> in a state <code>s</code>.</p></div></li></ul></div></td></tr></table></div></div><div class="top"><p class="src"><a id="v:enumSearch" class="def">enumSearch</a> :: (<a href="../base-4.18.2.1/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> v, <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (s -&gt; <a href="../base-4.18.2.1/Data-Either.html#t:Either" title="Data.Either">Either</a> v [a]) -&gt; Search s v a m <a href="src/DP.html#enumSearch" class="link">Source</a> <a href="#v:enumSearch" class="selflink">#</a></p><div class="doc"><p>Given a function `s -&gt; Either v [a]` indicating whether a state is either:
- terminal with value <code>v</code>
- allows for actions `[a]` to be taken
this procedure exhaustively searches the list for the action with the optimal objective.</p></div></div><div class="top"><p class="src"><a id="v:uniSearch" class="def">uniSearch</a> :: (<a href="../base-4.18.2.1/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> v, <a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="../base-4.18.2.1/Numeric.html#t:Floating" title="Numeric">Floating</a> x) =&gt; <a href="../base-4.18.2.1/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; (x -&gt; a) -&gt; x -&gt; x -&gt; Search s v a m <a href="src/DP.html#uniSearch" class="link">Source</a> <a href="#v:uniSearch" class="selflink">#</a></p><div class="doc"><p>Given an injection <code>mk</code> of values <code>x</code> into actions <code>a</code>,
this procedure performs a golden section search over <code>x</code> for the objective of `mk x`. </p></div></div><div class="top"><p class="src"><a id="v:execDP" class="def">execDP</a> :: Hashable s =&gt; <a href="DP.html#t:DPProblem" title="DP">DPProblem</a> s v a <a href="../base-4.18.2.1/System-IO.html#t:IO" title="System.IO">IO</a> -&gt; s -&gt; <a href="../base-4.18.2.1/System-IO.html#t:IO" title="System.IO">IO</a> (HashMap s (v, <a href="../base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)) <a href="src/DP.html#execDP" class="link">Source</a> <a href="#v:execDP" class="selflink">#</a></p><div class="doc"><p><code><a href="DP.html#v:execDP" title="DP">execDP</a></code> solves a <code><a href="DP.html#t:DPProblem" title="DP">DPProblem</a></code> in <code><a href="../base-4.18.2.1/System-IO.html#t:IO" title="System.IO">IO</a></code> from a given initial state, returning the entire table mapping states to their optimal actions and objective values.
Uses an <code><a href="../base-4.18.2.1/Data-IORef.html#t:IORef" title="Data.IORef">IORef</a></code> to a <code>HashMap</code> for memoization.</p></div></div><div class="top"><p class="src"><a id="v:reducedP" class="def">reducedP</a> :: (<a href="../base-4.18.2.1/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="../base-4.18.2.1/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> v, Hashable s) =&gt; HashMap s (v, <a href="../base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) -&gt; <a href="DP.html#t:DPProblem" title="DP">DPProblem</a> s v a m -&gt; <a href="DP.html#t:DPProblem" title="DP">DPProblem</a> s v a m <a href="src/DP.html#reducedP" class="link">Source</a> <a href="#v:reducedP" class="selflink">#</a></p><div class="doc"><p>A &quot;trick&quot; to reduce the output of <code><a href="DP.html#v:execDP" title="DP">execDP</a></code> to only the relevant parts.
Instantiate this with the output of an <code><a href="DP.html#v:execDP" title="DP">execDP</a></code> call and rerun <code><a href="DP.html#v:execDP" title="DP">execDP</a></code> with this problem instead.</p></div></div><div class="top"><p class="src"><a id="v:reducedDP" class="def">reducedDP</a> :: (Hashable s, <a href="../base-4.18.2.1/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> v) =&gt; <a href="DP.html#t:DPProblem" title="DP">DPProblem</a> s v a <a href="../base-4.18.2.1/System-IO.html#t:IO" title="System.IO">IO</a> -&gt; s -&gt; <a href="../base-4.18.2.1/System-IO.html#t:IO" title="System.IO">IO</a> (HashMap s (v, <a href="../base-4.18.2.1/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)) <a href="src/DP.html#reducedDP" class="link">Source</a> <a href="#v:reducedDP" class="selflink">#</a></p><div class="doc"><p><code><a href="DP.html#v:reducedDP" title="DP">reducedDP</a></code> solves a <code><a href="DP.html#t:DPProblem" title="DP">DPProblem</a></code> in <code><a href="../base-4.18.2.1/System-IO.html#t:IO" title="System.IO">IO</a></code> from a given initial state, returning the table mapping reachable states to their optimal actions and objective values.</p><p>A state <code>s</code> is reachable if it's either initial, or the objective value of a reachable state <code>s'</code> after taking the optimal action refers to <code>s</code>.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.29.2</p></div></body></html>